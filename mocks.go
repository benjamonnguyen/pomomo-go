// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package pomomo

import (
	"context"

	mock "github.com/stretchr/testify/mock"
)

// NewMockSessionRepo creates a new instance of MockSessionRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSessionRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSessionRepo {
	mock := &MockSessionRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSessionRepo is an autogenerated mock type for the SessionRepo type
type MockSessionRepo struct {
	mock.Mock
}

type MockSessionRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSessionRepo) EXPECT() *MockSessionRepo_Expecter {
	return &MockSessionRepo_Expecter{mock: &_m.Mock}
}

// DeleteSession provides a mock function for the type MockSessionRepo
func (_mock *MockSessionRepo) DeleteSession(ctx context.Context, id string) (ExistingSessionRecord, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSession")
	}

	var r0 ExistingSessionRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (ExistingSessionRecord, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ExistingSessionRecord); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(ExistingSessionRecord)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSessionRepo_DeleteSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSession'
type MockSessionRepo_DeleteSession_Call struct {
	*mock.Call
}

// DeleteSession is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockSessionRepo_Expecter) DeleteSession(ctx interface{}, id interface{}) *MockSessionRepo_DeleteSession_Call {
	return &MockSessionRepo_DeleteSession_Call{Call: _e.mock.On("DeleteSession", ctx, id)}
}

func (_c *MockSessionRepo_DeleteSession_Call) Run(run func(ctx context.Context, id string)) *MockSessionRepo_DeleteSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSessionRepo_DeleteSession_Call) Return(existingSessionRecord ExistingSessionRecord, err error) *MockSessionRepo_DeleteSession_Call {
	_c.Call.Return(existingSessionRecord, err)
	return _c
}

func (_c *MockSessionRepo_DeleteSession_Call) RunAndReturn(run func(ctx context.Context, id string) (ExistingSessionRecord, error)) *MockSessionRepo_DeleteSession_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSettings provides a mock function for the type MockSessionRepo
func (_mock *MockSessionRepo) DeleteSettings(ctx context.Context, id string) (ExistingSessionSettingsRecord, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSettings")
	}

	var r0 ExistingSessionSettingsRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (ExistingSessionSettingsRecord, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ExistingSessionSettingsRecord); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(ExistingSessionSettingsRecord)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSessionRepo_DeleteSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSettings'
type MockSessionRepo_DeleteSettings_Call struct {
	*mock.Call
}

// DeleteSettings is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockSessionRepo_Expecter) DeleteSettings(ctx interface{}, id interface{}) *MockSessionRepo_DeleteSettings_Call {
	return &MockSessionRepo_DeleteSettings_Call{Call: _e.mock.On("DeleteSettings", ctx, id)}
}

func (_c *MockSessionRepo_DeleteSettings_Call) Run(run func(ctx context.Context, id string)) *MockSessionRepo_DeleteSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSessionRepo_DeleteSettings_Call) Return(existingSessionSettingsRecord ExistingSessionSettingsRecord, err error) *MockSessionRepo_DeleteSettings_Call {
	_c.Call.Return(existingSessionSettingsRecord, err)
	return _c
}

func (_c *MockSessionRepo_DeleteSettings_Call) RunAndReturn(run func(ctx context.Context, id string) (ExistingSessionSettingsRecord, error)) *MockSessionRepo_DeleteSettings_Call {
	_c.Call.Return(run)
	return _c
}

// GetByStatus provides a mock function for the type MockSessionRepo
func (_mock *MockSessionRepo) GetByStatus(ctx context.Context, status ...SessionStatus) ([]ExistingSessionRecord, error) {
	var tmpRet mock.Arguments
	if len(status) > 0 {
		tmpRet = _mock.Called(ctx, status)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetByStatus")
	}

	var r0 []ExistingSessionRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...SessionStatus) ([]ExistingSessionRecord, error)); ok {
		return returnFunc(ctx, status...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...SessionStatus) []ExistingSessionRecord); ok {
		r0 = returnFunc(ctx, status...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ExistingSessionRecord)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ...SessionStatus) error); ok {
		r1 = returnFunc(ctx, status...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSessionRepo_GetByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByStatus'
type MockSessionRepo_GetByStatus_Call struct {
	*mock.Call
}

// GetByStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - status ...SessionStatus
func (_e *MockSessionRepo_Expecter) GetByStatus(ctx interface{}, status ...interface{}) *MockSessionRepo_GetByStatus_Call {
	return &MockSessionRepo_GetByStatus_Call{Call: _e.mock.On("GetByStatus",
		append([]interface{}{ctx}, status...)...)}
}

func (_c *MockSessionRepo_GetByStatus_Call) Run(run func(ctx context.Context, status ...SessionStatus)) *MockSessionRepo_GetByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []SessionStatus
		var variadicArgs []SessionStatus
		if len(args) > 1 {
			variadicArgs = args[1].([]SessionStatus)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockSessionRepo_GetByStatus_Call) Return(existingSessionRecords []ExistingSessionRecord, err error) *MockSessionRepo_GetByStatus_Call {
	_c.Call.Return(existingSessionRecords, err)
	return _c
}

func (_c *MockSessionRepo_GetByStatus_Call) RunAndReturn(run func(ctx context.Context, status ...SessionStatus) ([]ExistingSessionRecord, error)) *MockSessionRepo_GetByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetSession provides a mock function for the type MockSessionRepo
func (_mock *MockSessionRepo) GetSession(ctx context.Context, id string) (ExistingSessionRecord, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 ExistingSessionRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (ExistingSessionRecord, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ExistingSessionRecord); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(ExistingSessionRecord)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSessionRepo_GetSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSession'
type MockSessionRepo_GetSession_Call struct {
	*mock.Call
}

// GetSession is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockSessionRepo_Expecter) GetSession(ctx interface{}, id interface{}) *MockSessionRepo_GetSession_Call {
	return &MockSessionRepo_GetSession_Call{Call: _e.mock.On("GetSession", ctx, id)}
}

func (_c *MockSessionRepo_GetSession_Call) Run(run func(ctx context.Context, id string)) *MockSessionRepo_GetSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSessionRepo_GetSession_Call) Return(existingSessionRecord ExistingSessionRecord, err error) *MockSessionRepo_GetSession_Call {
	_c.Call.Return(existingSessionRecord, err)
	return _c
}

func (_c *MockSessionRepo_GetSession_Call) RunAndReturn(run func(ctx context.Context, id string) (ExistingSessionRecord, error)) *MockSessionRepo_GetSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetSettings provides a mock function for the type MockSessionRepo
func (_mock *MockSessionRepo) GetSettings(ctx context.Context, id string) (ExistingSessionSettingsRecord, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetSettings")
	}

	var r0 ExistingSessionSettingsRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (ExistingSessionSettingsRecord, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ExistingSessionSettingsRecord); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(ExistingSessionSettingsRecord)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSessionRepo_GetSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSettings'
type MockSessionRepo_GetSettings_Call struct {
	*mock.Call
}

// GetSettings is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockSessionRepo_Expecter) GetSettings(ctx interface{}, id interface{}) *MockSessionRepo_GetSettings_Call {
	return &MockSessionRepo_GetSettings_Call{Call: _e.mock.On("GetSettings", ctx, id)}
}

func (_c *MockSessionRepo_GetSettings_Call) Run(run func(ctx context.Context, id string)) *MockSessionRepo_GetSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSessionRepo_GetSettings_Call) Return(existingSessionSettingsRecord ExistingSessionSettingsRecord, err error) *MockSessionRepo_GetSettings_Call {
	_c.Call.Return(existingSessionSettingsRecord, err)
	return _c
}

func (_c *MockSessionRepo_GetSettings_Call) RunAndReturn(run func(ctx context.Context, id string) (ExistingSessionSettingsRecord, error)) *MockSessionRepo_GetSettings_Call {
	_c.Call.Return(run)
	return _c
}

// InsertSession provides a mock function for the type MockSessionRepo
func (_mock *MockSessionRepo) InsertSession(context1 context.Context, sessionRecord SessionRecord) (ExistingSessionRecord, error) {
	ret := _mock.Called(context1, sessionRecord)

	if len(ret) == 0 {
		panic("no return value specified for InsertSession")
	}

	var r0 ExistingSessionRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, SessionRecord) (ExistingSessionRecord, error)); ok {
		return returnFunc(context1, sessionRecord)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, SessionRecord) ExistingSessionRecord); ok {
		r0 = returnFunc(context1, sessionRecord)
	} else {
		r0 = ret.Get(0).(ExistingSessionRecord)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, SessionRecord) error); ok {
		r1 = returnFunc(context1, sessionRecord)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSessionRepo_InsertSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertSession'
type MockSessionRepo_InsertSession_Call struct {
	*mock.Call
}

// InsertSession is a helper method to define mock.On call
//   - context1 context.Context
//   - sessionRecord SessionRecord
func (_e *MockSessionRepo_Expecter) InsertSession(context1 interface{}, sessionRecord interface{}) *MockSessionRepo_InsertSession_Call {
	return &MockSessionRepo_InsertSession_Call{Call: _e.mock.On("InsertSession", context1, sessionRecord)}
}

func (_c *MockSessionRepo_InsertSession_Call) Run(run func(context1 context.Context, sessionRecord SessionRecord)) *MockSessionRepo_InsertSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 SessionRecord
		if args[1] != nil {
			arg1 = args[1].(SessionRecord)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSessionRepo_InsertSession_Call) Return(existingSessionRecord ExistingSessionRecord, err error) *MockSessionRepo_InsertSession_Call {
	_c.Call.Return(existingSessionRecord, err)
	return _c
}

func (_c *MockSessionRepo_InsertSession_Call) RunAndReturn(run func(context1 context.Context, sessionRecord SessionRecord) (ExistingSessionRecord, error)) *MockSessionRepo_InsertSession_Call {
	_c.Call.Return(run)
	return _c
}

// InsertSettings provides a mock function for the type MockSessionRepo
func (_mock *MockSessionRepo) InsertSettings(context1 context.Context, sessionSettingsRecord SessionSettingsRecord) (ExistingSessionSettingsRecord, error) {
	ret := _mock.Called(context1, sessionSettingsRecord)

	if len(ret) == 0 {
		panic("no return value specified for InsertSettings")
	}

	var r0 ExistingSessionSettingsRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, SessionSettingsRecord) (ExistingSessionSettingsRecord, error)); ok {
		return returnFunc(context1, sessionSettingsRecord)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, SessionSettingsRecord) ExistingSessionSettingsRecord); ok {
		r0 = returnFunc(context1, sessionSettingsRecord)
	} else {
		r0 = ret.Get(0).(ExistingSessionSettingsRecord)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, SessionSettingsRecord) error); ok {
		r1 = returnFunc(context1, sessionSettingsRecord)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSessionRepo_InsertSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertSettings'
type MockSessionRepo_InsertSettings_Call struct {
	*mock.Call
}

// InsertSettings is a helper method to define mock.On call
//   - context1 context.Context
//   - sessionSettingsRecord SessionSettingsRecord
func (_e *MockSessionRepo_Expecter) InsertSettings(context1 interface{}, sessionSettingsRecord interface{}) *MockSessionRepo_InsertSettings_Call {
	return &MockSessionRepo_InsertSettings_Call{Call: _e.mock.On("InsertSettings", context1, sessionSettingsRecord)}
}

func (_c *MockSessionRepo_InsertSettings_Call) Run(run func(context1 context.Context, sessionSettingsRecord SessionSettingsRecord)) *MockSessionRepo_InsertSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 SessionSettingsRecord
		if args[1] != nil {
			arg1 = args[1].(SessionSettingsRecord)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSessionRepo_InsertSettings_Call) Return(existingSessionSettingsRecord ExistingSessionSettingsRecord, err error) *MockSessionRepo_InsertSettings_Call {
	_c.Call.Return(existingSessionSettingsRecord, err)
	return _c
}

func (_c *MockSessionRepo_InsertSettings_Call) RunAndReturn(run func(context1 context.Context, sessionSettingsRecord SessionSettingsRecord) (ExistingSessionSettingsRecord, error)) *MockSessionRepo_InsertSettings_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSession provides a mock function for the type MockSessionRepo
func (_mock *MockSessionRepo) UpdateSession(ctx context.Context, id string, s SessionRecord) (ExistingSessionRecord, error) {
	ret := _mock.Called(ctx, id, s)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSession")
	}

	var r0 ExistingSessionRecord
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, SessionRecord) (ExistingSessionRecord, error)); ok {
		return returnFunc(ctx, id, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, SessionRecord) ExistingSessionRecord); ok {
		r0 = returnFunc(ctx, id, s)
	} else {
		r0 = ret.Get(0).(ExistingSessionRecord)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, SessionRecord) error); ok {
		r1 = returnFunc(ctx, id, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSessionRepo_UpdateSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSession'
type MockSessionRepo_UpdateSession_Call struct {
	*mock.Call
}

// UpdateSession is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - s SessionRecord
func (_e *MockSessionRepo_Expecter) UpdateSession(ctx interface{}, id interface{}, s interface{}) *MockSessionRepo_UpdateSession_Call {
	return &MockSessionRepo_UpdateSession_Call{Call: _e.mock.On("UpdateSession", ctx, id, s)}
}

func (_c *MockSessionRepo_UpdateSession_Call) Run(run func(ctx context.Context, id string, s SessionRecord)) *MockSessionRepo_UpdateSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 SessionRecord
		if args[2] != nil {
			arg2 = args[2].(SessionRecord)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockSessionRepo_UpdateSession_Call) Return(existingSessionRecord ExistingSessionRecord, err error) *MockSessionRepo_UpdateSession_Call {
	_c.Call.Return(existingSessionRecord, err)
	return _c
}

func (_c *MockSessionRepo_UpdateSession_Call) RunAndReturn(run func(ctx context.Context, id string, s SessionRecord) (ExistingSessionRecord, error)) *MockSessionRepo_UpdateSession_Call {
	_c.Call.Return(run)
	return _c
}
